/**
 * This header is generated by class-dump-z 0.2a.
 * class-dump-z is Copyright (C) 2009 by KennyTM~, licensed under GPLv3.
 *
 * Source: /System/Library/PrivateFrameworks/MusicLibrary.framework/MusicLibrary
 */

typedef struct _NSZone NSZone;

typedef struct sqlite3 sqlite3;

typedef struct __CFDictionary* CFDictionaryRef;

typedef struct iPhoneSortKeyBuilder iPhoneSortKeyBuilder;

typedef struct sqlite3_stmt sqlite3_stmt;

typedef struct MLArtworkFormatSpec {
	unsigned _field1;
	unsigned _field2;
	unsigned _field3;
	unsigned _field4;
	int _field5;
	int _field6;
	BOOL _field7;
} MLArtworkFormatSpec;

template<>
struct _Select1st<std::pair<const long long, ML3NameOrder> >;

template<>
struct equal_to<long long>;

template<>
struct hash<long long>;

typedef struct _Mod_range_hashing Mod_range_hashing;

template<>
struct allocator<std::tr1::__detail::_Hash_node<std::pair<const long long, ML3NameOrder>, false> >;

template<>
struct _Hash_node<std::pair<const long long, ML3NameOrder>, false>;

typedef struct _Prime_rehash_policy {
	float _M_max_load_factor;
	float _M_growth_factor;
	unsigned long _M_next_resize;
} Prime_rehash_policy;

template<>
struct unordered_map<long long, ML3NameOrder, std::tr1::hash<long long>, std::equal_to<long long>, std::allocator<std::pair<const long long, ML3NameOrder>>, false> {
	_Select1st<std::pair<const long long, ML3NameOrder> > _field1;
	equal_to<long long> _field2;
	hash<long long> _field3;
	Mod_range_hashing _field4;
	allocator<std::tr1::__detail::_Hash_node<std::pair<const long long, ML3NameOrder>, false> > _field5;
	_Hash_node<std::pair<const long long, ML3NameOrder>, false>** _field6;
	unsigned _field7;
	unsigned _field8;
	Prime_rehash_policy _field9;
};

typedef struct {
	long long _field1;
	int _field2;
} XXStruct_Cy4r_A;

typedef struct CGImage* CGImageRef;

typedef struct CGColorSpace* CGColorSpaceRef;

typedef struct {
	unsigned _field1;
	unsigned _field2;
	unsigned _field3;
	unsigned _field4;
	BOOL _field5;
	BOOL _field6;
	BOOL _field7;
	BOOL _field8;
} XXStruct_$eUQoB;

typedef struct CGPoint {
	float _field1;
	float _field2;
} CGPoint;

typedef struct CGSize {
	float _field1;
	float _field2;
} CGSize;

typedef struct CGRect {
	CGPoint _field1;
	CGSize _field2;
} CGRect;

typedef struct _NSRange {
	unsigned location;
	unsigned length;
} NSRange;

typedef struct SearchCriteriaList SearchCriteriaList;

typedef struct ChapterData ChapterData;

typedef struct MLArtworkInstanceInfo {
	MLArtworkFormatSpec _field1;
	CGRect _field2;
} MLArtworkInstanceInfo;

typedef struct sqlite3_module {
	int _field1;
	/*function-pointer*/ void* _field2;
	/*function-pointer*/ void* _field3;
	/*function-pointer*/ void* _field4;
	/*function-pointer*/ void* _field5;
	/*function-pointer*/ void* _field6;
	/*function-pointer*/ void* _field7;
	/*function-pointer*/ void* _field8;
	/*function-pointer*/ void* _field9;
	/*function-pointer*/ void* _field10;
	/*function-pointer*/ void* _field11;
	/*function-pointer*/ void* _field12;
	/*function-pointer*/ void* _field13;
	/*function-pointer*/ void* _field14;
	/*function-pointer*/ void* _field15;
	/*function-pointer*/ void* _field16;
	/*function-pointer*/ void* _field17;
	/*function-pointer*/ void* _field18;
	/*function-pointer*/ void* _field19;
	/*function-pointer*/ void* _field20;
	/*function-pointer*/ void* _field21;
	/*function-pointer*/ void* _field22;
	/*function-pointer*/ void* _field23;
} sqlite3_module;

typedef struct __MLDBValue {
	sqlite3_stmt* _field1;
	int _field2;
} MLDBValue;

typedef struct _Vector_impl {
	long long* _M_start;
	long long* _M_finish;
	long long* _M_end_of_storage;
} Vector_impl;

template<>
struct vector<long long, std::allocator<long long> > {
	Vector_impl _M_impl;
};

typedef struct _Vector_impl {
	char* _M_start;
	char* _M_finish;
	char* _M_end_of_storage;
} Vector_impl;

template<>
struct vector<unsigned char, std::allocator<unsigned char> > {
	Vector_impl _M_impl;
};

template<>
struct _Identity<long long>;

template<>
struct allocator<std::tr1::__detail::_Hash_node<long long, false> >;

template<>
struct _Hash_node<long long, false>;

template<>
struct unordered_set<long long, std::tr1::hash<long long>, std::equal_to<long long>, std::allocator<long long>, false> {
	_Identity<long long> _field1;
	equal_to<long long> _field2;
	hash<long long> _field3;
	Mod_range_hashing _field4;
	allocator<std::tr1::__detail::_Hash_node<long long, false> > _field5;
	_Hash_node<long long, false>** _field6;
	unsigned _field7;
	unsigned _field8;
	Prime_rehash_policy _field9;
};

template<>
struct _Select1st<std::pair<const long long, NSString *> >;

template<>
struct allocator<std::tr1::__detail::_Hash_node<std::pair<const long long, NSString *>, false> >;

template<>
struct _Hash_node<std::pair<const long long, NSString *>, false>;

template<>
struct unordered_map<long long, NSString *, std::tr1::hash<long long>, std::equal_to<long long>, std::allocator<std::pair<const long long, NSString *>>, false> {
	_Select1st<std::pair<const long long, NSString *> > _M_extract;
	equal_to<long long> _M_eq;
	hash<long long> _M_h1;
	Mod_range_hashing _M_h2;
	allocator<std::tr1::__detail::_Hash_node<std::pair<const long long, NSString *>, false> > _M_node_allocator;
	_Hash_node<std::pair<const long long, NSString* >, false>** _M_buckets;
	unsigned _M_bucket_count;
	unsigned _M_element_count;
	Prime_rehash_policy _M_rehash_policy;
};


